

  * [ 前言 ](../../)
  * 物联网平台操作 
    * [ 前言 ](../)
    * 快速开始 
      * [ introduction ](../quick-start/introduction.html)
      * [ demo ](../quick-start/demo.html)
    * 开发指南 
      * [ assets ](../dev-guide/assets.html)
      * [ commons-api ](../dev-guide/commons-api.html)
      * [ crud ](../dev-guide/crud.html)
      * [ custom-sql-term ](../dev-guide/custom-sql-term.html)
      * [ dashboard ](../dev-guide/dashboard.html)
      * [ device-firmware ](../dev-guide/device-firmware.html)
      * [ mqtt-subs ](../dev-guide/mqtt-subs.html)
      * [ multi-tenant ](../dev-guide/multi-tenant.html)
      * [ websocket-subs ](../dev-guide/websocket-subs.html)
    * 最佳实践 
      * [ auto-register ](auto-register.html)
      * [ coap-connection ](coap-connection.html)
      * [ device-alarm ](device-alarm.html)
      * [ device-connection ](device-connection.html)
      * [ device-gateway-connection ](device-gateway-connection.html)
      * [ http-connection ](http-connection.html)
      * [ jetlinks对接其他云平台教程-HTTP方式 ](jetlinks对接其他云平台教程-HTTP方式.html)
      * [ open-api ](open-api.html)
      * [ sort-link ](sort-link.html)
      * [ start ](start.html)
      * [ tcp-connection ](tcp-connection.html)
      * [ udp-connection ](udp-connection.html)
    * 使用手册 
      * [ DemoDevice ](../basics-guide/DemoDevice.html)
      * [ device-manager ](../basics-guide/device-manager.html)
      * [ protocol-support ](../basics-guide/protocol-support.html)
      * [ quick-start ](../basics-guide/quick-start.html)
      * [ rule-engine ](../basics-guide/rule-engine.html)
      * [ ziduanquanxian ](../basics-guide/ziduanquanxian.html)
  * 萌蜂项目规范 
    * [ 前言 ](../../萌蜂项目规范/)
    * 一、开发项 
      * [ 快速开始 ](../../萌蜂项目规范/开发项/idea-start.html)
      * [ 环境维护 ](../../萌蜂项目规范/开发项/环境维护.html)
      * [ 代码管理 ](../../萌蜂项目规范/开发项/代码管理.html)
      * [ 后端开发 ](../../萌蜂项目规范/开发项/后端开发.html)
      * [ 前端开发 ](../../萌蜂项目规范/开发项/前端开发.html)
      * [ 工程专项 ](../../萌蜂项目规范/开发项/工程专项.html)
      * [ 其他规约 ](../../萌蜂项目规范/开发项/其他规约.html)
      * [ 流程管理 ](../../萌蜂项目规范/开发项/流程管理.html)
    * 二、知识点 
      * [ 安装 Centos7 ](../../萌蜂项目规范/知识点/install-centos7.html)
      * [ Centos 创建用户 ](../../萌蜂项目规范/知识点/centos-create-user.html)
      * [ Centos 安装桌面环境 ](../../萌蜂项目规范/知识点/centos-install-gnome.html)
      * [ Centos 安装KVM ](../../萌蜂项目规范/知识点/centos-install-kvm.html)
      * [ Centos 安装VNC ](../../萌蜂项目规范/知识点/centos-install-vnc.html)
      * [ Centos 安装Pip ](../../萌蜂项目规范/知识点/centos-install-pip.html)
      * [ Docker Compose ](../../萌蜂项目规范/知识点/docker-compose.html)
      * [ FFmpeg ](../../萌蜂项目规范/知识点/ffmpeg.html)
      * [ Nginx 代理 ](../../萌蜂项目规范/知识点/nginx-prefix.html)
      * [ Nginx Rtmp ](../../萌蜂项目规范/知识点/nginx-rtmp.html)
      * [ Nohup ](../../萌蜂项目规范/知识点/nohup.html)
      * [ NodeJs ](../../萌蜂项目规范/知识点/nodejs-upgrade.html)
      * [ Http Code ](../../萌蜂项目规范/知识点/http-code.html)
      * [ String.format() ](../../萌蜂项目规范/知识点/string-format.html)
  * JAVA开发规范 
    * [ 前言 ](../../JAVA开发规范/)
    * 一、编程规约 
      * [ （一）命名风格 ](../../JAVA开发规范/编程规约/命名风格.html)
      * [ （二）常量定义 ](../../JAVA开发规范/编程规约/常量定义.html)
      * [ （三）代码格式 ](../../JAVA开发规范/编程规约/代码格式.html)
      * [ （四）OOP规范 ](../../JAVA开发规范/编程规约/OOP规范.html)
      * [ （五）集合处理 ](../../JAVA开发规范/编程规约/集合处理.html)
      * [ （六）并发处理 ](../../JAVA开发规范/编程规约/并发处理.html)
      * [ （七）控制语句 ](../../JAVA开发规范/编程规约/控制语句.html)
      * [ （八）注释规约 ](../../JAVA开发规范/编程规约/注释规约.html)
    * 二、异常日志 
      * [ （一）异常处理 ](../../JAVA开发规范/异常日志/异常处理.html)
      * [ （二）日志规范 ](../../JAVA开发规范/异常日志/日志规约.html)
      * [ （三）其他 ](../../JAVA开发规范/异常日志/其他.html)
    * [ 三、单元测试 ](../../JAVA开发规范/单元测试.html)
    * [ 四、安全规约 ](../../JAVA开发规范/安全规约.html)
    * 五、MySQL数据库 
      * [ （一）建表规约 ](../../JAVA开发规范/MySQL数据库/建表规约.html)
      * [ （二）索引规约 ](../../JAVA开发规范/MySQL数据库/索引规约.html)
      * [ （三）SQL语句 ](../../JAVA开发规范/MySQL数据库/SQL语句.html)
      * [ （四）ORM映射 ](../../JAVA开发规范/MySQL数据库/ORM映射.html)
    * 六、工程结构 
      * [ （一）应用分层 ](../../JAVA开发规范/工程结构/应用分层.html)
      * [ （二）二方库依赖 ](../../JAVA开发规范/工程结构/二方库依赖.html)
      * [ （三）服务器 ](../../JAVA开发规范/工程结构/服务器.html)
    * [ 附：本手册专有名词 ](../../JAVA开发规范/本手册专有名词.html)
  * MIS系统操作手册 
    * [ MIS系统操作手册 ](../../用户操作手册/用户操作手册.html)
  * MIS系统环境临时记录 
    * [ MIS系统环境临时记录 ](../../MIS系统环境临时记录/组态和大屏连接地址配置.html)
  *   * [ Published with GitBook ](https://www.gitbook.com)

#  __[jetlinks对接其他云平台教程-HTTP方式](../..)

# MF-IOT通过HTTP对接其他云平台教程

### 第一步定义消息编码解码器

    
    
    public class HttpMessageCodec implements DeviceMessageCodec {
    
        // 定义一个通用的响应，用于收到请求后响应
        private static final SimpleHttpResponseMessage response = SimpleHttpResponseMessage
                .builder()
                .payload(Unpooled.wrappedBuffer("{success:true}".getBytes()))
                .contentType(MediaType.APPLICATION_JSON)
                .status(200)
                .build();
    
        @Override
        public Transport getSupportTransport() {
            return DefaultTransport.HTTP;
        }
    
        @Nonnull
        @Override
        public Publisher<? extends Message> decode(@Nonnull MessageDecodeContext context){
            // 把消息转换为http消息
             HttpExchangeMessage message = (HttpExchangeMessage) context.getMessage();
            String url = message.getUrl();
            // 这里通常需要判断是不是自己需要的请求，如果不是直接返回/响应，防止非法请求
            if (!url.endsWith("/eventRcv")) {
                return message.response(response).then(Mono.empty());
            }
            // 获取具体消息类型
            ByteBuf payload = message.getPayload();
            String string = payload.toString(StandardCharsets.UTF_8);
            // 通常来说，云平台通知的定义为事件消息（也可以定义成别的消息）
            EventMessage eventMessage = new EventMessage();
            eventMessage.setEvent("test");
            eventMessage.setDeviceId(string);
            eventMessage.setData(string);
            eventMessage.setMessageId(String.valueOf(System.currentTimeMillis()));
            eventMessage.setTimestamp(System.currentTimeMillis());
            return message.response(response).thenMany(Flux.just(eventMessage));
        }
    
    
        @Nonnull
        @Override
        public Publisher<? extends EncodedMessage> encode(@Nonnull MessageEncodeContext context) {
            // 对接其他云平台，命令发起不在这里处理，所以这里返回空就可以了
            return Mono.empty();
        }
    
    }
    

### 第二步 定义一个消息拦截器

    
    
    @Slf4j
    @AllArgsConstructor
    @Getter
    @Setter
    public class HttpMessageSenderInterceptor implements DeviceMessageSenderInterceptor{
        // 通过构造器注入一个编码消息处理器，用于消息的持久化
        private DecodedClientMessageHandler handler;
    
        private static final WebClient webclient=WebClient.builder().build();
       /**
         * 在消息发送后触发.
         *
         * @param device  设备操作接口
         * @param message 源消息
         * @param reply   回复的消息
         * @param <R>     回复的消息类型
         * @return 新的回复结果
         */
        public <R extends DeviceMessage> Flux<R> afterSent(DeviceOperator device, DeviceMessage message, Flux<R> reply) {
            return Flux.from(
                // 从配置中获取url等各种请求所需参数
                device.getConfigs("url")
                            .flatMap(values->{
                                String url=values.getValue("url").map(Value::asString).orElse(null);
                                // 通常发起请求都是通过方法调用
                                FunctionInvokeMessage invokeMessage = (FunctionInvokeMessage) message;
                                // 从命令发起的上下文中获取消息体
                              List<FunctionParameter> inputs = invokeMessage.getInputs();
                                Map< String, Object> body=iputs
                                    .stream()
                                    .collect(Collectors
                                             .toMap(FunctionParameter::getName,             FunctionParameter::getValue));
                                return webclient  // 构造WebClient
                                    .post()  // 指定请求类型
                                    .uri(url) // 请求路径
                                    .bodyValue(body) // 请求参数
                                       .retrieve() // 发起请求
                                       .bodyToMono(String.class) // 响应参数
                                       .flatMap(s -> {
                                        // 响应参数包装为功能回复参数
                                           FunctionInvokeMessageReply reply1 = new FunctionInvokeMessageReply();
                                           reply1.setSuccess(true);
                                           reply1.setMessage(s);
                                           reply1.setDeviceId(message.getDeviceId());
                                           reply1.setMessageId(message.getMessageId());
                                           reply1.setTimestamp(System.currentTimeMillis());
                                           reply1.setFunctionId(((FunctionInvokeMessage) message).getFunctionId());
                                   return Mono.just(reply1)
                                           .map(deviceMessage->(R)deviceMessage);
                               })
                               // 消息持久化
                               .flatMap(msg->handler.handleMessage(device,msg)
                                       .thenReturn(msg));
                            })
                    );
        }
    }
    

### 第三步 定义一个设备状态检测器

    
    
    /**
    * 这个接口会在进入设备详情页面和刷新设备状态时调用
    */
    @Slf4j
    public class HttpDeviceStateChecker implements DeviceStateChecker {
        @Override
        public @NotNull Mono<Byte> checkState(@NotNull DeviceOperator device) {
            // 如果第三方平台有提供设备状态查询接口，则调用接口确定设备状态，否则设置为设备在线，方便发起功能或者属性查询
            return Mono.just(DeviceState.online);
        }
    }
    

### 第四步 定义协议处理器

    
    
    public class HttpProtocolSupportProvider implements ProtocolSupportProvider{
    
            private static final DefaultConfigMetadata httpRequest = new DefaultConfigMetadata(
                "Http请求配置"
                , "")
                .add("url", "url", " http请求地址", new StringType());
    
        @Override
        public Mono<? extends ProtocolSupport> create(ServiceContext serviceContext){
            CompositeProtocolSupport support = new CompositeProtocolSupport();
            support.setId("http-demo-v1");
            support.setName("http调用第三方接口DEMO");
            support.setDescription("http调用第三方接口DEMO");
            support.setMetadataCodec(new JetLinksDeviceMetadataCodec());
            // 设置一个编解码入口
            HttpMessageCodec codec = new HttpMessageCodec();
            support.addMessageCodecSupport(DefaultTransport.HTTP, () -> Mono.just(codec));
            // 添加配置项定义
            support.addConfigMetadata(DefaultTransport.HTTP, httpRequest);
            HttpDeviceStateChecker httpDeviceStateChecker = new HttpDeviceStateChecker();
            // 设置设备状态检查接口
            support.setDeviceStateChecker(httpDeviceStateChecker);
            // 设置HTTP消息拦截器，用于发送HTTP消息
            serviceContext.getService(DecodedClientMessageHandler.class)
                    .ifPresent(handler -> support.addMessageSenderInterceptor(new HttpMessageSenderInterceptor(handler)));
            return Mono.just(support);
        }
    }
    

#  results matching ""

# No results matching ""

[ __](http-connection.html) [ __](open-api.html)

